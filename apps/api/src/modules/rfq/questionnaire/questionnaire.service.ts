/* eslint-disable @typescript-eslint/no-explicit-any */
// Note: This file uses 'any' types for database queries because the new models
// are not yet generated by Prisma. After running `npx prisma generate`,
// you can remove the eslint-disable and fix the types.

import { prisma } from '../../../lib/prisma.js';
import { knowledgeBaseService } from '../knowledge-base/knowledge-base.service.js';
import { questionnaireTemplates, coverageRules } from './questionnaire.templates.js';
import type {
  QuestionnaireAnswers,
  Rule,
  RuleAction,
  RuleCondition,
  Questionnaire,
  QuestionSection,
  Question,
} from './questionnaire.types.js';

// Use any for now - will be properly typed after prisma generate
const db = prisma as any;

export interface CoverageRecommendation {
  policyType: string;
  policyTypeHe: string;
  recommendedLimit: number;
  isMandatory: boolean;
  endorsements: string[];
  description?: string;
  descriptionHe?: string;
  adjustmentReason?: string;
}

// Database template types
interface DbQuestion {
  id: string;
  questionId: string;
  label: string;
  labelHe: string;
  description: string | null;
  descriptionHe: string | null;
  type: string;
  options: unknown;
  placeholder: string | null;
  placeholderHe: string | null;
  required: boolean;
  order: number;
  min: number | null;
  max: number | null;
  showIf: unknown;
  riskWeight: number | null;
  policyAffinity: string[];
}

interface DbSection {
  id: string;
  title: string;
  titleHe: string;
  description: string | null;
  descriptionHe: string | null;
  order: number;
  showIf: unknown;
  questions: DbQuestion[];
}

interface DbRule {
  id: string;
  name: string;
  nameHe: string;
  description: string | null;
  priority: number;
  isActive: boolean;
  conditions: unknown;
  actions: unknown;
}

interface DbTemplate {
  id: string;
  sector: string;
  sectorHe: string;
  description: string | null;
  descriptionHe: string | null;
  version: string;
  isActive: boolean;
  sections: DbSection[];
  rules: DbRule[];
}

export class QuestionnaireService {
  // Get questionnaire template by sector - prefers database, falls back to hardcoded
  async getTemplateAsync(sector: string): Promise<Questionnaire | null> {
    // Try database first
    try {
      const dbTemplate = await db.questionnaireTemplate.findUnique({
        where: { sector: sector.toUpperCase() },
        include: {
          sections: {
            include: {
              questions: {
                orderBy: { order: 'asc' },
              },
            },
            orderBy: { order: 'asc' },
          },
          rules: {
            where: { isActive: true },
            orderBy: { priority: 'asc' },
          },
        },
      });

      if (dbTemplate && dbTemplate.isActive) {
        return this.convertDbTemplateToQuestionnaire(dbTemplate as DbTemplate);
      }
    } catch {
      // Model may not exist yet, fall back to hardcoded
    }

    // Fall back to hardcoded templates
    const template = questionnaireTemplates[sector] || questionnaireTemplates['GENERIC'];
    return template || null;
  }

  // Synchronous version for backwards compatibility (uses hardcoded only)
  getTemplate(sector: string): Questionnaire {
    const template = questionnaireTemplates[sector] || questionnaireTemplates['GENERIC'];
    // GENERIC template always exists in hardcoded templates
    return template as Questionnaire;
  }

  // Get all available sectors from both database and hardcoded
  async getAvailableSectorsAsync(): Promise<string[]> {
    // Get hardcoded sectors first
    const hardcodedSectors = Object.keys(questionnaireTemplates).filter((s) => s !== 'GENERIC');

    // Try to get database sectors
    try {
      const dbTemplates = await db.questionnaireTemplate.findMany({
        where: { isActive: true },
        select: { sector: true },
      });
      const dbSectors = dbTemplates.map((t: any) => t.sector);

      // Merge and deduplicate
      const allSectors = [...new Set([...dbSectors, ...hardcodedSectors])];
      return allSectors.sort();
    } catch {
      // Model may not exist yet, return hardcoded only
      return hardcodedSectors.sort();
    }
  }

  // Synchronous version for backwards compatibility
  getAvailableSectors(): string[] {
    return Object.keys(questionnaireTemplates).filter((s) => s !== 'GENERIC');
  }

  // Get rules for a sector - prefers database, falls back to hardcoded
  async getRulesAsync(sector: string): Promise<Rule[]> {
    // Try database first
    try {
      const dbTemplate = await db.questionnaireTemplate.findUnique({
        where: { sector: sector.toUpperCase() },
        include: {
          rules: {
            where: { isActive: true },
            orderBy: { priority: 'asc' },
          },
        },
      });

      if (dbTemplate && dbTemplate.rules.length > 0) {
        return dbTemplate.rules.map((rule: any) => this.convertDbRuleToRule(rule as DbRule));
      }
    } catch {
      // Model may not exist yet, fall back to hardcoded
    }

    // Fall back to hardcoded rules
    return coverageRules;
  }

  // Convert database template to Questionnaire interface
  private convertDbTemplateToQuestionnaire(dbTemplate: DbTemplate): Questionnaire {
    return {
      id: dbTemplate.id,
      sector: dbTemplate.sector,
      version: dbTemplate.version,
      sections: dbTemplate.sections.map((section) => this.convertDbSectionToSection(section)),
    };
  }

  private convertDbSectionToSection(dbSection: DbSection): QuestionSection {
    return {
      id: dbSection.id,
      title: dbSection.title,
      titleHe: dbSection.titleHe,
      description: dbSection.description || undefined,
      descriptionHe: dbSection.descriptionHe || undefined,
      showIf: dbSection.showIf as QuestionSection['showIf'],
      questions: dbSection.questions.map((q) => this.convertDbQuestionToQuestion(q)),
    };
  }

  private convertDbQuestionToQuestion(dbQuestion: DbQuestion): Question {
    return {
      id: dbQuestion.questionId,
      type: dbQuestion.type as Question['type'],
      label: dbQuestion.label,
      labelHe: dbQuestion.labelHe,
      description: dbQuestion.description || undefined,
      descriptionHe: dbQuestion.descriptionHe || undefined,
      required: dbQuestion.required,
      options: dbQuestion.options as Question['options'],
      placeholder: dbQuestion.placeholder || undefined,
      placeholderHe: dbQuestion.placeholderHe || undefined,
      min: dbQuestion.min || undefined,
      max: dbQuestion.max || undefined,
      showIf: dbQuestion.showIf as Question['showIf'],
      riskWeight: dbQuestion.riskWeight || undefined,
      affectsPolicy: dbQuestion.policyAffinity,
    };
  }

  private convertDbRuleToRule(dbRule: DbRule): Rule {
    return {
      id: dbRule.id,
      name: dbRule.name,
      description: dbRule.description || '',
      priority: dbRule.priority,
      conditions: dbRule.conditions as RuleCondition[],
      actions: dbRule.actions as RuleAction[],
    };
  }

  // Save questionnaire answers
  async saveAnswers(clientId: string, answers: QuestionnaireAnswers, status = 'draft') {
    return prisma.rfqQuestionnaire.create({
      data: {
        clientId,
        answers,
        status,
      },
    });
  }

  // Update questionnaire answers
  async updateAnswers(questionnaireId: string, answers: QuestionnaireAnswers, status?: string) {
    return prisma.rfqQuestionnaire.update({
      where: { id: questionnaireId },
      data: {
        answers,
        ...(status && { status }),
      },
    });
  }

  // Get questionnaire by ID
  async getQuestionnaire(questionnaireId: string) {
    return prisma.rfqQuestionnaire.findUnique({
      where: { id: questionnaireId },
      include: { client: true },
    });
  }

  // Get questionnaires for a client
  async getClientQuestionnaires(clientId: string) {
    return prisma.rfqQuestionnaire.findMany({
      where: { clientId },
      orderBy: { createdAt: 'desc' },
    });
  }

  // Generate coverage recommendations based on answers
  async generateRecommendations(
    sector: string,
    answers: QuestionnaireAnswers
  ): Promise<CoverageRecommendation[]> {
    // Get base requirements from knowledge base
    const baseRequirements = await knowledgeBaseService.findBySector(sector);

    if (baseRequirements.length === 0) {
      // Fall back to generic requirements
      const genericRequirements = await knowledgeBaseService.findBySector('GENERIC');
      if (genericRequirements.length === 0) {
        return [];
      }
    }

    // Initialize recommendations from base requirements
    const recommendations: Map<string, CoverageRecommendation> = new Map();

    for (const req of baseRequirements) {
      recommendations.set(req.policyType, {
        policyType: req.policyType,
        policyTypeHe: req.policyTypeHe,
        recommendedLimit: Number(req.recommendedLimit) || 0,
        isMandatory: req.isMandatory,
        endorsements: (req.commonEndorsements as string[]) || [],
        description: req.description || undefined,
        descriptionHe: req.descriptionHe || undefined,
      });
    }

    // Apply rules based on answers - use database rules if available
    const rules = await this.getRulesAsync(sector);
    const applicableRules = this.evaluateRulesFromList(answers, rules);

    for (const rule of applicableRules) {
      for (const action of rule.actions) {
        this.applyAction(recommendations, action, rule.name);
      }
    }

    return Array.from(recommendations.values()).sort((a, b) => {
      // Mandatory first, then by limit
      if (a.isMandatory !== b.isMandatory) return a.isMandatory ? -1 : 1;
      return b.recommendedLimit - a.recommendedLimit;
    });
  }

  // Evaluate which rules apply based on answers from a given list
  private evaluateRulesFromList(answers: QuestionnaireAnswers, rules: Rule[]): Rule[] {
    const applicableRules: Rule[] = [];

    for (const rule of rules) {
      const allConditionsMet = rule.conditions.every((condition) => {
        const value = answers[condition.field];
        if (value === undefined || value === null) return false;

        switch (condition.operator) {
          case 'equals':
            return value === condition.value;
          case 'notEquals':
            return value !== condition.value;
          case 'greaterThan':
            return typeof value === 'number' && value > (condition.value as number);
          case 'lessThan':
            return typeof value === 'number' && value < (condition.value as number);
          case 'in':
            return Array.isArray(condition.value) && condition.value.includes(value as string);
          case 'contains':
            return (
              Array.isArray(value) && value.includes(condition.value as string)
            );
          default:
            return false;
        }
      });

      if (allConditionsMet) {
        applicableRules.push(rule);
      }
    }

    // Sort by priority (lower number = higher priority)
    return applicableRules.sort((a, b) => a.priority - b.priority);
  }

  // Legacy method using hardcoded rules
  private evaluateRules(answers: QuestionnaireAnswers): Rule[] {
    return this.evaluateRulesFromList(answers, coverageRules);
  }

  // Apply a rule action to recommendations
  private applyAction(
    recommendations: Map<string, CoverageRecommendation>,
    action: RuleAction,
    ruleName: string
  ) {
    const policyType = action.policyType;
    if (!policyType) return;

    let rec = recommendations.get(policyType);

    switch (action.type) {
      case 'addPolicy':
        if (!rec) {
          recommendations.set(policyType, {
            policyType,
            policyTypeHe: policyType, // Should be translated
            recommendedLimit: action.amount || 5000000,
            isMandatory: action.mandatory || false,
            endorsements: [],
            adjustmentReason: ruleName,
          });
        }
        break;

      case 'removePolicy':
        recommendations.delete(policyType);
        break;

      case 'adjustLimit':
        if (rec && action.multiplier) {
          rec.recommendedLimit = Math.round(rec.recommendedLimit * action.multiplier);
          rec.adjustmentReason = (rec.adjustmentReason ? rec.adjustmentReason + ', ' : '') + ruleName;
        }
        break;

      case 'addEndorsement':
        if (rec && action.endorsement) {
          if (!rec.endorsements.includes(action.endorsement)) {
            rec.endorsements.push(action.endorsement);
          }
        }
        break;

      case 'setMandatory':
        if (rec) {
          rec.isMandatory = action.mandatory ?? true;
        }
        break;
    }
  }

  // Calculate risk score from answers - async version using database templates
  async calculateRiskScoreAsync(sector: string, answers: QuestionnaireAnswers): Promise<number> {
    const template = await this.getTemplateAsync(sector);
    if (!template) {
      return 50; // Default medium risk if no template found
    }
    return this.calculateRiskScoreFromTemplate(template, answers);
  }

  // Calculate risk score from answers - sync version using hardcoded templates
  calculateRiskScore(sector: string, answers: QuestionnaireAnswers): number {
    const template = this.getTemplate(sector);
    if (!template) {
      return 50; // Default medium risk if no template found
    }
    return this.calculateRiskScoreFromTemplate(template, answers);
  }

  // Shared logic for calculating risk score from a template
  private calculateRiskScoreFromTemplate(
    template: Questionnaire,
    answers: QuestionnaireAnswers
  ): number {
    let totalWeight = 0;
    let weightedScore = 0;

    for (const section of template.sections) {
      for (const question of section.questions) {
        if (question.riskWeight) {
          totalWeight += Math.abs(question.riskWeight);
          const answer = answers[question.id];

          if (answer !== undefined && answer !== null) {
            // Normalize answer to 0-1 scale based on type
            let normalizedValue = 0;

            switch (question.type) {
              case 'boolean':
                normalizedValue = answer === true ? 1 : 0;
                break;
              case 'number':
              case 'currency':
                // Normalize based on min/max if available
                const numVal = Number(answer);
                const min = question.min || 0;
                const max = question.max || numVal * 2;
                normalizedValue = (numVal - min) / (max - min);
                break;
              case 'select':
                // Assume later options = higher risk
                const options = question.options || [];
                const idx = options.findIndex((o) => o.value === answer);
                normalizedValue = idx >= 0 ? idx / (options.length - 1) : 0;
                break;
              case 'multiselect':
                // More selections = higher risk
                const selections = Array.isArray(answer) ? answer.length : 0;
                const totalOptions = question.options?.length || 1;
                normalizedValue = selections / totalOptions;
                break;
            }

            // Apply risk weight (can be negative for risk-reducing factors)
            if (question.riskWeight > 0) {
              weightedScore += normalizedValue * question.riskWeight;
            } else {
              weightedScore += (1 - normalizedValue) * Math.abs(question.riskWeight);
            }
          }
        }
      }
    }

    // Return score as percentage (0-100)
    return totalWeight > 0 ? Math.round((weightedScore / totalWeight) * 100) : 50;
  }
}

export const questionnaireService = new QuestionnaireService();
