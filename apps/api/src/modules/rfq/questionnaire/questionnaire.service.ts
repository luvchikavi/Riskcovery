// @ts-nocheck
/* eslint-disable @typescript-eslint/no-explicit-any */
// Note: This file uses 'any' types for database queries because the new models
// are not yet generated by Prisma. After running `npx prisma generate`,
// you can remove the eslint-disable and fix the types.

import { prisma } from '../../../lib/prisma.js';
import { knowledgeBaseService } from '../knowledge-base/knowledge-base.service.js';
import { productService } from '../products/product.service.js';
import { insurerService } from '../../insurer/insurer.service.js';
import { questionnaireTemplates, coverageRules } from './questionnaire.templates.js';
import type {
  QuestionnaireAnswers,
  Rule,
  RuleAction,
  RuleCondition,
  Questionnaire,
  QuestionSection,
  Question,
  EnrichedCoverageRecommendation,
  CoverageGap,
} from './questionnaire.types.js';
import { STANDARD_COVERAGE_GAPS } from './questionnaire.types.js';

// Use any for now - will be properly typed after prisma generate
const db = prisma as any;

export interface CoverageRecommendation {
  policyType: string;
  policyTypeHe: string;
  recommendedLimit: number;
  isMandatory: boolean;
  endorsements: string[];
  description?: string;
  descriptionHe?: string;
  adjustmentReason?: string;
}

export interface InsurerSuggestion {
  insurerCode: string;
  insurerNameHe: string;
  insurerNameEn: string;
  bitStandard: string | null;
  extensionCount: number;
  strengths: string[];
  weaknesses: string[];
  score: number;
}

// Database template types
interface DbQuestion {
  id: string;
  questionId: string;
  label: string;
  labelHe: string;
  description: string | null;
  descriptionHe: string | null;
  type: string;
  options: unknown;
  placeholder: string | null;
  placeholderHe: string | null;
  required: boolean;
  order: number;
  min: number | null;
  max: number | null;
  showIf: unknown;
  riskWeight: number | null;
  policyAffinity: string[];
}

interface DbSection {
  id: string;
  title: string;
  titleHe: string;
  description: string | null;
  descriptionHe: string | null;
  order: number;
  showIf: unknown;
  questions: DbQuestion[];
}

interface DbRule {
  id: string;
  name: string;
  nameHe: string;
  description: string | null;
  priority: number;
  isActive: boolean;
  conditions: unknown;
  actions: unknown;
}

interface DbTemplate {
  id: string;
  sector: string;
  sectorHe: string;
  description: string | null;
  descriptionHe: string | null;
  version: string;
  isActive: boolean;
  sections: DbSection[];
  rules: DbRule[];
}

export class QuestionnaireService {
  // Get questionnaire template by sector - prefers database, falls back to hardcoded
  async getTemplateAsync(sector: string): Promise<Questionnaire | null> {
    // Try database first
    try {
      const dbTemplate = await db.questionnaireTemplate.findUnique({
        where: { sector: sector.toUpperCase() },
        include: {
          sections: {
            include: {
              questions: {
                orderBy: { order: 'asc' },
              },
            },
            orderBy: { order: 'asc' },
          },
          rules: {
            where: { isActive: true },
            orderBy: { priority: 'asc' },
          },
        },
      });

      if (dbTemplate && dbTemplate.isActive) {
        return this.convertDbTemplateToQuestionnaire(dbTemplate as DbTemplate);
      }
    } catch {
      // Model may not exist yet, fall back to hardcoded
    }

    // Fall back to hardcoded templates
    const template = questionnaireTemplates[sector] || questionnaireTemplates['GENERIC'];
    return template || null;
  }

  // Synchronous version for backwards compatibility (uses hardcoded only)
  getTemplate(sector: string): Questionnaire {
    const template = questionnaireTemplates[sector] || questionnaireTemplates['GENERIC'];
    // GENERIC template always exists in hardcoded templates
    return template as Questionnaire;
  }

  // Get all available sectors from both database and hardcoded
  async getAvailableSectorsAsync(): Promise<string[]> {
    // Get hardcoded sectors first
    const hardcodedSectors = Object.keys(questionnaireTemplates).filter((s) => s !== 'GENERIC');

    // Try to get database sectors
    try {
      const dbTemplates = await db.questionnaireTemplate.findMany({
        where: { isActive: true },
        select: { sector: true },
      });
      const dbSectors = dbTemplates.map((t: any) => t.sector);

      // Merge and deduplicate
      const allSectors = [...new Set([...dbSectors, ...hardcodedSectors])];
      return allSectors.sort();
    } catch {
      // Model may not exist yet, return hardcoded only
      return hardcodedSectors.sort();
    }
  }

  // Synchronous version for backwards compatibility
  getAvailableSectors(): string[] {
    return Object.keys(questionnaireTemplates).filter((s) => s !== 'GENERIC');
  }

  // Get rules for a sector - prefers database, falls back to hardcoded
  async getRulesAsync(sector: string): Promise<Rule[]> {
    // Try database first
    try {
      const dbTemplate = await db.questionnaireTemplate.findUnique({
        where: { sector: sector.toUpperCase() },
        include: {
          rules: {
            where: { isActive: true },
            orderBy: { priority: 'asc' },
          },
        },
      });

      if (dbTemplate && dbTemplate.rules.length > 0) {
        return dbTemplate.rules.map((rule: any) => this.convertDbRuleToRule(rule as DbRule));
      }
    } catch {
      // Model may not exist yet, fall back to hardcoded
    }

    // Fall back to hardcoded rules
    return coverageRules;
  }

  // Convert database template to Questionnaire interface
  private convertDbTemplateToQuestionnaire(dbTemplate: DbTemplate): Questionnaire {
    return {
      id: dbTemplate.id,
      sector: dbTemplate.sector,
      version: dbTemplate.version,
      sections: dbTemplate.sections.map((section) => this.convertDbSectionToSection(section)),
    };
  }

  private convertDbSectionToSection(dbSection: DbSection): QuestionSection {
    return {
      id: dbSection.id,
      title: dbSection.title,
      titleHe: dbSection.titleHe,
      description: dbSection.description || undefined,
      descriptionHe: dbSection.descriptionHe || undefined,
      showIf: dbSection.showIf as QuestionSection['showIf'],
      questions: dbSection.questions.map((q) => this.convertDbQuestionToQuestion(q)),
    };
  }

  private convertDbQuestionToQuestion(dbQuestion: DbQuestion): Question {
    return {
      id: dbQuestion.questionId,
      type: dbQuestion.type as Question['type'],
      label: dbQuestion.label,
      labelHe: dbQuestion.labelHe,
      description: dbQuestion.description || undefined,
      descriptionHe: dbQuestion.descriptionHe || undefined,
      required: dbQuestion.required,
      options: dbQuestion.options as Question['options'],
      placeholder: dbQuestion.placeholder || undefined,
      placeholderHe: dbQuestion.placeholderHe || undefined,
      min: dbQuestion.min || undefined,
      max: dbQuestion.max || undefined,
      showIf: dbQuestion.showIf as Question['showIf'],
      riskWeight: dbQuestion.riskWeight || undefined,
      affectsPolicy: dbQuestion.policyAffinity,
    };
  }

  private convertDbRuleToRule(dbRule: DbRule): Rule {
    return {
      id: dbRule.id,
      name: dbRule.name,
      description: dbRule.description || '',
      priority: dbRule.priority,
      conditions: dbRule.conditions as RuleCondition[],
      actions: dbRule.actions as RuleAction[],
    };
  }

  // Save questionnaire answers
  async saveAnswers(clientId: string, answers: QuestionnaireAnswers, status = 'draft') {
    return prisma.rfqQuestionnaire.create({
      data: {
        clientId,
        answers,
        status,
      },
    });
  }

  // Update questionnaire answers
  async updateAnswers(questionnaireId: string, answers: QuestionnaireAnswers, status?: string) {
    return prisma.rfqQuestionnaire.update({
      where: { id: questionnaireId },
      data: {
        answers,
        ...(status && { status }),
      },
    });
  }

  // Get questionnaire by ID
  async getQuestionnaire(questionnaireId: string) {
    return prisma.rfqQuestionnaire.findUnique({
      where: { id: questionnaireId },
      include: { client: true },
    });
  }

  // Get questionnaires for a client
  async getClientQuestionnaires(clientId: string) {
    return prisma.rfqQuestionnaire.findMany({
      where: { clientId },
      orderBy: { createdAt: 'desc' },
    });
  }

  // Generate coverage recommendations based on answers (legacy format)
  async generateRecommendations(
    sector: string,
    answers: QuestionnaireAnswers
  ): Promise<CoverageRecommendation[]> {
    // Get base requirements from knowledge base
    const baseRequirements = await knowledgeBaseService.findBySector(sector);

    if (baseRequirements.length === 0) {
      // Fall back to generic requirements
      const genericRequirements = await knowledgeBaseService.findBySector('GENERIC');
      if (genericRequirements.length === 0) {
        return [];
      }
    }

    // Initialize recommendations from base requirements
    const recommendations: Map<string, CoverageRecommendation> = new Map();

    for (const req of baseRequirements) {
      recommendations.set(req.policyType, {
        policyType: req.policyType,
        policyTypeHe: req.policyTypeHe,
        recommendedLimit: Number(req.recommendedLimit) || 0,
        isMandatory: req.isMandatory,
        endorsements: (req.commonEndorsements as string[]) || [],
        description: req.description || undefined,
        descriptionHe: req.descriptionHe || undefined,
      });
    }

    // Apply rules based on answers - use database rules if available
    const rules = await this.getRulesAsync(sector);
    const applicableRules = this.evaluateRulesFromList(answers, rules);

    for (const rule of applicableRules) {
      for (const action of rule.actions) {
        this.applyAction(recommendations, action, rule.name);
      }
    }

    return Array.from(recommendations.values()).sort((a, b) => {
      // Mandatory first, then by limit
      if (a.isMandatory !== b.isMandatory) return a.isMandatory ? -1 : 1;
      return b.recommendedLimit - a.recommendedLimit;
    });
  }

  // Generate enriched recommendations using the product catalog
  async generateEnrichedRecommendations(
    sector: string,
    answers: QuestionnaireAnswers
  ): Promise<{ recommendations: EnrichedCoverageRecommendation[]; coverageGaps: CoverageGap[] }> {
    // Get products for this sector from the catalog
    const sectorProducts = await productService.findBySector(sector);

    // Build enriched recommendations
    const recommendations: Map<string, EnrichedCoverageRecommendation> = new Map();

    for (const product of sectorProducts) {
      // Get extensions and relations for each product
      const [extensions, exclusions, relations] = await Promise.all([
        productService.getExtensions(product.code),
        productService.getExclusions(product.code),
        productService.getRelatedProducts(product.code),
      ]);

      recommendations.set(product.code, {
        productCode: product.code,
        productNameHe: product.nameHe,
        productNameEn: product.nameEn,
        category: product.category,
        coverageTrigger: product.coverageTrigger,
        recommendedLimit: this.getDefaultLimit(product.code),
        isMandatory: (product as any).necessity === 'mandatory',
        necessity: (product as any).necessity || 'recommended',
        endorsements: [],
        extensions: extensions.map((ext) => ({
          code: ext.code,
          nameHe: ext.nameHe,
          nameEn: ext.nameEn,
          chapterCode: ext.chapterCode ?? undefined,
          defaultLimit: ext.defaultLimit ? Number(ext.defaultLimit) : undefined,
          isFirstLoss: ext.isFirstLoss,
        })),
        exclusionCount: exclusions.length,
        relatedProducts: relations.map((rel) => ({
          productCode: rel.product.code,
          productNameHe: rel.product.nameHe,
          productNameEn: rel.product.nameEn,
          relationType: rel.relationType,
          description: rel.description ?? undefined,
        })),
        description: product.description ?? undefined,
        descriptionHe: product.descriptionHe ?? undefined,
      });
    }

    // Apply rules
    const rules = await this.getRulesAsync(sector);
    const applicableRules = this.evaluateRulesFromList(answers, rules);
    const coverageGaps: CoverageGap[] = [];

    for (const rule of applicableRules) {
      for (const action of rule.actions) {
        this.applyEnrichedAction(recommendations, action, rule.name, coverageGaps);
      }
    }

    // Add standard coverage gaps based on sector
    const standardGaps = this.getApplicableCoverageGaps(sector, answers);
    coverageGaps.push(...standardGaps);

    const sortedRecommendations = Array.from(recommendations.values()).sort((a, b) => {
      if (a.isMandatory !== b.isMandatory) return a.isMandatory ? -1 : 1;
      return b.recommendedLimit - a.recommendedLimit;
    });

    return { recommendations: sortedRecommendations, coverageGaps };
  }

  // Evaluate which rules apply based on answers from a given list
  private evaluateRulesFromList(answers: QuestionnaireAnswers, rules: Rule[]): Rule[] {
    const applicableRules: Rule[] = [];

    for (const rule of rules) {
      const allConditionsMet = rule.conditions.every((condition) => {
        const value = answers[condition.field];
        if (value === undefined || value === null) return false;

        switch (condition.operator) {
          case 'equals':
            return value === condition.value;
          case 'notEquals':
            return value !== condition.value;
          case 'greaterThan':
            return typeof value === 'number' && value > (condition.value as number);
          case 'lessThan':
            return typeof value === 'number' && value < (condition.value as number);
          case 'in':
            return Array.isArray(condition.value) && condition.value.includes(value as string);
          case 'contains':
            return (
              Array.isArray(value) && value.includes(condition.value as string)
            );
          default:
            return false;
        }
      });

      if (allConditionsMet) {
        applicableRules.push(rule);
      }
    }

    // Sort by priority (lower number = higher priority)
    return applicableRules.sort((a, b) => a.priority - b.priority);
  }

  // Legacy method using hardcoded rules
  private evaluateRules(answers: QuestionnaireAnswers): Rule[] {
    return this.evaluateRulesFromList(answers, coverageRules);
  }

  // Apply a rule action to recommendations (legacy format)
  private applyAction(
    recommendations: Map<string, CoverageRecommendation>,
    action: RuleAction,
    ruleName: string
  ) {
    const policyType = action.policyType;
    if (!policyType) return;

    // Resolve old policy codes to new product codes
    const resolvedCode = knowledgeBaseService.resolveProductCode(policyType);
    let rec = recommendations.get(resolvedCode) || recommendations.get(policyType);

    switch (action.type) {
      case 'addPolicy':
        if (!rec) {
          recommendations.set(resolvedCode, {
            policyType: resolvedCode,
            policyTypeHe: resolvedCode,
            recommendedLimit: action.amount || 5000000,
            isMandatory: action.mandatory || false,
            endorsements: [],
            adjustmentReason: ruleName,
          });
        }
        break;

      case 'removePolicy':
        recommendations.delete(resolvedCode);
        recommendations.delete(policyType);
        break;

      case 'adjustLimit':
        if (rec && action.multiplier) {
          rec.recommendedLimit = Math.round(rec.recommendedLimit * action.multiplier);
          rec.adjustmentReason = (rec.adjustmentReason ? rec.adjustmentReason + ', ' : '') + ruleName;
        }
        break;

      case 'addEndorsement':
        if (rec && action.endorsement) {
          if (!rec.endorsements.includes(action.endorsement)) {
            rec.endorsements.push(action.endorsement);
          }
        }
        break;

      case 'setMandatory':
        if (rec) {
          rec.isMandatory = action.mandatory ?? true;
        }
        break;

      case 'addExtension':
      case 'removeExtension':
      case 'flagCoverageGap':
        // These are handled in applyEnrichedAction; no-op for legacy format
        break;
    }
  }

  // Apply a rule action to enriched recommendations
  private applyEnrichedAction(
    recommendations: Map<string, EnrichedCoverageRecommendation>,
    action: RuleAction,
    ruleName: string,
    coverageGaps: CoverageGap[]
  ) {
    const policyType = action.policyType;

    if (action.type === 'flagCoverageGap') {
      if (action.gapType) {
        coverageGaps.push({
          type: action.gapType,
          nameHe: action.gapDescription || action.gapType,
          nameEn: action.gapType,
          description: action.gapDescription || '',
          descriptionHe: action.gapDescription || '',
          severity: 'advisory',
        });
      }
      return;
    }

    if (!policyType) return;

    const resolvedCode = knowledgeBaseService.resolveProductCode(policyType);
    const rec = recommendations.get(resolvedCode) || recommendations.get(policyType);

    switch (action.type) {
      case 'addPolicy':
        if (!rec) {
          recommendations.set(resolvedCode, {
            productCode: resolvedCode,
            productNameHe: resolvedCode,
            productNameEn: resolvedCode,
            category: 'other',
            coverageTrigger: 'occurrence',
            recommendedLimit: action.amount || 5000000,
            isMandatory: action.mandatory || false,
            necessity: action.mandatory ? 'mandatory' : 'recommended',
            endorsements: [],
            extensions: [],
            exclusionCount: 0,
            relatedProducts: [],
            adjustmentReason: ruleName,
          });
        }
        break;

      case 'removePolicy':
        recommendations.delete(resolvedCode);
        recommendations.delete(policyType);
        break;

      case 'adjustLimit':
        if (rec && action.multiplier) {
          rec.recommendedLimit = Math.round(rec.recommendedLimit * action.multiplier);
          rec.adjustmentReason = (rec.adjustmentReason ? rec.adjustmentReason + ', ' : '') + ruleName;
        }
        break;

      case 'addEndorsement':
        if (rec && action.endorsement) {
          if (!rec.endorsements.includes(action.endorsement)) {
            rec.endorsements.push(action.endorsement);
          }
        }
        break;

      case 'setMandatory':
        if (rec) {
          rec.isMandatory = action.mandatory ?? true;
          rec.necessity = (action.mandatory ?? true) ? 'mandatory' : rec.necessity;
        }
        break;

      case 'addExtension':
        if (rec && action.extensionCode) {
          const alreadyHas = rec.extensions.some((e) => e.code === action.extensionCode);
          if (!alreadyHas) {
            rec.extensions.push({
              code: action.extensionCode,
              nameHe: action.extensionName || action.extensionCode,
              nameEn: action.extensionName || action.extensionCode,
              isFirstLoss: false,
            });
          }
          rec.adjustmentReason = (rec.adjustmentReason ? rec.adjustmentReason + ', ' : '') + ruleName;
        }
        break;

      case 'removeExtension':
        if (rec && action.extensionCode) {
          rec.extensions = rec.extensions.filter((e) => e.code !== action.extensionCode);
        }
        break;
    }
  }

  // Determine applicable coverage gaps based on sector and answers
  private getApplicableCoverageGaps(sector: string, answers: QuestionnaireAnswers): CoverageGap[] {
    const gaps: CoverageGap[] = [];

    // E&O is always relevant for consulting/technology
    if (['CONSULTING', 'TECHNOLOGY', 'FINANCIAL_SERVICES'].includes(sector)) {
      const eoGap = STANDARD_COVERAGE_GAPS.find((g) => g.type === 'PROFESSIONAL_LIABILITY');
      if (eoGap) gaps.push({ ...eoGap, severity: 'warning' });
    }

    // D&O relevant for public companies or large companies
    const legalStructure = answers.legalStructure;
    if (legalStructure === 'public' || (answers.employeeCount && Number(answers.employeeCount) > 50)) {
      const doGap = STANDARD_COVERAGE_GAPS.find((g) => g.type === 'DIRECTORS_OFFICERS');
      if (doGap) gaps.push(doGap);
    }

    // Cyber relevant for tech, finance, healthcare
    if (['TECHNOLOGY', 'FINANCIAL_SERVICES', 'HEALTHCARE'].includes(sector)) {
      const cyberGap = STANDARD_COVERAGE_GAPS.find((g) => g.type === 'CYBER');
      if (cyberGap) gaps.push({ ...cyberGap, severity: 'warning' });
    }

    // Environmental for manufacturing, construction
    if (['MANUFACTURING', 'CONSTRUCTION', 'AGRICULTURE'].includes(sector)) {
      const envGap = STANDARD_COVERAGE_GAPS.find((g) => g.type === 'ENVIRONMENTAL');
      if (envGap) gaps.push(envGap);
    }

    // Marine for logistics with import/export
    if (sector === 'LOGISTICS' || answers.hasImportExport === true) {
      const marineGap = STANDARD_COVERAGE_GAPS.find((g) => g.type === 'MARINE');
      if (marineGap) gaps.push(marineGap);
    }

    // Motor vehicle is almost always relevant
    if (answers.vehicleCount && Number(answers.vehicleCount) > 0) {
      const motorGap = STANDARD_COVERAGE_GAPS.find((g) => g.type === 'MOTOR_VEHICLE');
      if (motorGap) gaps.push(motorGap);
    }

    return gaps;
  }

  // Get insurer suggestions for a set of recommended product codes.
  // For each product, queries all insurer policies, ranks by coverage breadth
  // (extension count, fewer weaknesses), and returns top 3.
  async getInsurerSuggestions(
    productCodes: string[]
  ): Promise<Record<string, InsurerSuggestion[]>> {
    const result: Record<string, InsurerSuggestion[]> = {};

    await Promise.all(
      productCodes.map(async (productCode) => {
        try {
          const comparisons = await insurerService.compareByProduct(productCode);
          if (comparisons.length === 0) {
            result[productCode] = [];
            return;
          }

          // Score each insurer: more extensions = better, fewer weaknesses = better
          const scored = comparisons.map((c) => {
            const extensionCount = c.extensions.length;
            const weaknessCount = Array.isArray(c.policy.weaknesses)
              ? (c.policy.weaknesses as string[]).length
              : 0;
            const strengthCount = Array.isArray(c.policy.strengths)
              ? (c.policy.strengths as string[]).length
              : 0;
            // Simple scoring: extensions + strengths - weaknesses
            const score = extensionCount + strengthCount * 2 - weaknessCount * 2;
            return { comparison: c, score, extensionCount };
          });

          // Sort by score descending, take top 3
          scored.sort((a, b) => b.score - a.score);
          const top = scored.slice(0, 3);

          result[productCode] = top.map((item) => ({
            insurerCode: item.comparison.insurer.code,
            insurerNameHe: item.comparison.insurer.nameHe,
            insurerNameEn: item.comparison.insurer.nameEn,
            bitStandard: item.comparison.policy.bitStandard,
            extensionCount: item.extensionCount,
            strengths: Array.isArray(item.comparison.policy.strengths)
              ? (item.comparison.policy.strengths as string[]).slice(0, 2)
              : [],
            weaknesses: Array.isArray(item.comparison.policy.weaknesses)
              ? (item.comparison.policy.weaknesses as string[]).slice(0, 2)
              : [],
            score: item.score,
          }));
        } catch {
          result[productCode] = [];
        }
      })
    );

    return result;
  }

  // Default recommended limits per product type (in ILS)
  private getDefaultLimit(productCode: string): number {
    const defaults: Record<string, number> = {
      FIRE_CONSEQUENTIAL_LOSS: 10000000,
      MECHANICAL_BREAKDOWN: 5000000,
      THIRD_PARTY_LIABILITY: 5000000,
      EMPLOYERS_LIABILITY: 10000000,
      PRODUCT_LIABILITY: 5000000,
      CASH_MONEY: 500000,
      FIDELITY_CRIME: 2000000,
      CARGO_IN_TRANSIT: 2000000,
      TERRORISM: 10000000,
      ELECTRONIC_EQUIPMENT: 3000000,
      HEAVY_ENGINEERING_EQUIPMENT: 5000000,
      CONTRACTOR_WORKS_CAR: 10000000,
    };
    return defaults[productCode] || 5000000;
  }

  // Calculate risk score from answers - async version using database templates
  async calculateRiskScoreAsync(sector: string, answers: QuestionnaireAnswers): Promise<number> {
    const template = await this.getTemplateAsync(sector);
    if (!template) {
      return 50; // Default medium risk if no template found
    }
    return this.calculateRiskScoreFromTemplate(template, answers);
  }

  // Calculate risk score from answers - sync version using hardcoded templates
  calculateRiskScore(sector: string, answers: QuestionnaireAnswers): number {
    const template = this.getTemplate(sector);
    if (!template) {
      return 50; // Default medium risk if no template found
    }
    return this.calculateRiskScoreFromTemplate(template, answers);
  }

  // Shared logic for calculating risk score from a template
  private calculateRiskScoreFromTemplate(
    template: Questionnaire,
    answers: QuestionnaireAnswers
  ): number {
    let totalWeight = 0;
    let weightedScore = 0;

    for (const section of template.sections) {
      for (const question of section.questions) {
        if (question.riskWeight) {
          totalWeight += Math.abs(question.riskWeight);
          const answer = answers[question.id];

          if (answer !== undefined && answer !== null) {
            // Normalize answer to 0-1 scale based on type
            let normalizedValue = 0;

            switch (question.type) {
              case 'boolean':
                normalizedValue = answer === true ? 1 : 0;
                break;
              case 'number':
              case 'currency':
                // Normalize based on min/max if available
                const numVal = Number(answer);
                const min = question.min || 0;
                const max = question.max || numVal * 2;
                normalizedValue = (numVal - min) / (max - min);
                break;
              case 'select':
                // Assume later options = higher risk
                const options = question.options || [];
                const idx = options.findIndex((o) => o.value === answer);
                normalizedValue = idx >= 0 ? idx / (options.length - 1) : 0;
                break;
              case 'multiselect':
                // More selections = higher risk
                const selections = Array.isArray(answer) ? answer.length : 0;
                const totalOptions = question.options?.length || 1;
                normalizedValue = selections / totalOptions;
                break;
            }

            // Apply risk weight (can be negative for risk-reducing factors)
            if (question.riskWeight > 0) {
              weightedScore += normalizedValue * question.riskWeight;
            } else {
              weightedScore += (1 - normalizedValue) * Math.abs(question.riskWeight);
            }
          }
        }
      }
    }

    // Return score as percentage (0-100)
    return totalWeight > 0 ? Math.round((weightedScore / totalWeight) * 100) : 50;
  }
}

export const questionnaireService = new QuestionnaireService();
